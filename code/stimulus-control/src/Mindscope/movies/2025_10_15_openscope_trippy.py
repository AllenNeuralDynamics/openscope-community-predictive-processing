# -*- coding: utf-8 -*-
"""OpenScope_Trippy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZsoMHkKtEqAt1XomOL4fhx_hmVB3_8Vt

# TRIPPY

by Dimitri Yatsenko

original paper: https://www.nature.com/articles/s41586-025-08790-w

https://github.com/cajal/pipeline/blob/master/matlab/schemas/%2Bvis/Trippy.m

This is a python translation of Dimitri's `Trippy.m`

SCALED FOR THE ALLEN INSTITUTE MONITOR AND VIEWING DISTANCE:
ASUS ProArt PA248Q (https://www.asus.com/us/displays-desktops/monitors/proart/proart-display-pa248q/)
1920x1200; 15 cm away, covering 120 * 95 degrees of visual space

**NOTE**: The *Nature* article doesn’t state a percentage, and the public dataset docs don’t expose a contrast field. Given the generation code, Trippy is rendered at 100% Michelson contrast by default unless an external step scaled it (which isn’t documented in the paper).

**PYTHON TRANSLATION OF ORIGINAL MATLAB CODE**

visually indistinguishable from the MATLAB movie and exactly reproducible on every run:

switches the RNG to MT19937 (like rng(seed,'twister') in MATLAB),

keeps all randomness behind a single rng object so runs are repeatable,

preserves your frozen Gaussian upscaler math and temporal Hanning pipeline
"""

# MICrONS Trippy — 10×15s trials concatenated (2.5 min total)
# 1920x1200 @ 30fps, H.264 MP4 (yuv420p)
# ------------------------------------------------------------------
# pip install numpy scipy imageio-ffmpeg imageio

from typing import Tuple, Generator as GenType
import numpy as np
import scipy.signal as sig
import imageio
from numpy.random import Generator, MT19937
from pathlib import Path

# =========================
# MATLAB-compatible helpers
# =========================
def hanning_window(L: int) -> np.ndarray:
    return np.hanning(L).astype(np.float32)

def gausswin_matlab(L: int, alpha: float) -> np.ndarray:
    n = np.arange(L, dtype=np.float32)
    N = (L - 1) / 2.0
    if N == 0:
        return np.ones(L, dtype=np.float32)
    x = (n - N) / N
    return np.exp(-0.5 * (alpha * x) ** 2).astype(np.float32)

def upsample_1d_along_axis(x: np.ndarray, factor: int, phase: int = 0, axis: int = 0) -> np.ndarray:
    assert factor >= 1 and 0 <= phase < factor
    x = np.asarray(x)
    new_shape = list(x.shape)
    new_shape[axis] = x.shape[axis] * factor
    y = np.zeros(new_shape, dtype=x.dtype)
    sl = [slice(None)] * y.ndim
    sl[axis] = slice(phase, None, factor)
    y[tuple(sl)] = x
    return y

# =========================
# Frozen Gaussian upsampler (two passes; verbatim math)
# =========================
def frozen_upscale(img: np.ndarray, factor: int) -> np.ndarray:
    out = img.astype(np.float32, copy=True)
    for _ in range(2):
        out = out.T
        ph = int(np.round(factor / 2.0))
        out = upsample_1d_along_axis(out, factor=factor, phase=ph, axis=0)
        L = out.shape[0]
        alpha = (np.sqrt(0.5) * L) / float(factor)
        k = gausswin_matlab(L, alpha).astype(np.float32)
        k = np.fft.ifftshift((factor / np.sum(k)) * k)
        Kf = np.fft.fft(k, n=L).astype(np.complex64)
        Xf = np.fft.fft(out, axis=0)
        out = np.fft.ifft(Kf[:, None] * Xf, axis=0).real.astype(np.float32)
    return out

# =========================
# Core Trippy
# =========================
class TrippyCond:
    def __init__(self, rng_seed: int, tex_ydim: int, tex_xdim: int, duration: float,
                 xnodes: int, ynodes: int, up_factor: int, temp_freq: float,
                 temp_kernel_length: int, spatial_freq: float):
        self.rng_seed = int(rng_seed)
        self.tex_ydim = int(tex_ydim)
        self.tex_xdim = int(tex_xdim)
        self.duration = float(duration)
        self.xnodes = int(xnodes)
        self.ynodes = int(ynodes)
        self.up_factor = int(up_factor)
        self.temp_freq = float(temp_freq)                 # cycles/s drift
        self.temp_kernel_length = int(temp_kernel_length) # odd
        self.spatial_freq = float(spatial_freq)           # cycles/deg (used in packing scale)

def make_packed_phase_movie(cond: TrippyCond, fps: int, degxy: Tuple[float, float],
                            rng: Generator) -> np.ndarray:
    nframes = int(np.ceil(cond.duration * fps))
    k = cond.temp_kernel_length
    k2 = int(np.ceil(k / 4))
    compensator = 8.0
    scale = compensator * cond.up_factor * cond.spatial_freq * float(degxy[0]) / cond.tex_xdim
    T0 = int(np.ceil((nframes + k - 1) / k2))
    return (scale * rng.random((T0, cond.ynodes * cond.xnodes), dtype=np.float32)).astype(np.float32)

def interp_time(phase: np.ndarray, cond: TrippyCond, fps: int) -> np.ndarray:
    nframes = int(np.ceil(cond.duration * fps))
    k = cond.temp_kernel_length
    k2 = int(np.ceil(k / 4))
    up = upsample_1d_along_axis(phase, factor=k2, phase=0, axis=0)
    tempKernel = hanning_window(k)
    tempKernel = (k2 / float(np.sum(tempKernel))) * tempKernel
    lp = sig.convolve(up, tempKernel[:, None], mode='valid').astype(np.float32)
    lp = lp[:nframes, :]
    t = (np.arange(1, nframes + 1, dtype=np.float32) / float(fps))
    lp = lp + t[:, None] * cond.temp_freq
    return lp  # (T, ynodes*xnodes)

def interp_space(phase_tn: np.ndarray, cond: TrippyCond) -> GenType[np.ndarray, None, None]:
    Ht, Wt = cond.tex_ydim, cond.tex_xdim
    f = cond.up_factor
    for i in range(phase_tn.shape[0]):
        low = phase_tn[i].reshape(cond.ynodes, cond.xnodes)
        up_img = frozen_upscale(low, f)
        yield up_img[:Ht, :Wt].astype(np.float32)

# =========================
# Frame generator for one 15s trial
# =========================
def trippy_trial_frames(
    cond: TrippyCond, fps: int, screen_deg_x: float, screen_deg_y: float,
    michelson_contrast: float = 1.0, mean_luminance: float = 0.5
) -> GenType[np.ndarray, None, None]:
    rng = Generator(MT19937(cond.rng_seed))
    packed = make_packed_phase_movie(cond, fps=fps, degxy=(screen_deg_x, screen_deg_y), rng=rng)
    phase_tn = interp_time(packed, cond, fps=fps)

    A = float(np.clip(michelson_contrast, 0.0, 1.0)) * float(mean_luminance)
    L = float(np.clip(mean_luminance, 0.0, 1.0))

    for phase_frame in interp_space(phase_tn, cond):
        lumin = L + A * np.cos(2.0 * np.pi * phase_frame, dtype=np.float32)
        frame_u8 = np.clip(lumin, 0.0, 1.0)
        frame_u8 = (frame_u8 * 255.0 + 0.5).astype(np.uint8)
        yield frame_u8

# =========================
# Concatenate trials and write one MP4
# =========================
def render_trippy_concatenated(
    outfile: str = "trippy_150s_1920x1200_30fps.mp4",
    trials: int = 10,               # 10 × 15s = 150s (2.5 min)
    trial_duration_s: float = 15.0,
    fps: int = 30,
    tex_x: int = 1920, tex_y: int = 1200,
    xnodes: int = 8, ynodes: int = 6,
    up_factor: int | None = None,   # if None, compute the minimum needed
    temp_kernel_len: int = 61,
    temp_freq_cps: float = 4.0,
    spatial_freq_cpd: float = 0.06,
    screen_deg_x: float = 160.0,    # adjust if you want 120×95 etc.
    screen_deg_y: float = 90.0,
    seed0: int = 0,                 # base seed; per-trial seeds = seed0 + t
    michelson_contrast: float = 1.0,
    mean_luminance: float = 0.5,
    codec: str = "libx264", pix_fmt: str = "yuv420p", crf: int = 18, bitrate: str | None = None
):
    if up_factor is None:
        up_factor = int(np.ceil(max(tex_x / xnodes, tex_y / ynodes)))

    writer = imageio.get_writer(
        outfile, format="ffmpeg", fps=fps, codec=codec,
        output_params=(["-pix_fmt", pix_fmt] +
                       (["-crf", str(crf)] if crf is not None else []) +
                       (["-b:v", bitrate] if bitrate else []))
    )
    try:
        for t in range(trials):
            cond = TrippyCond(
                rng_seed=seed0 + t,
                tex_ydim=tex_y, tex_xdim=tex_x,
                duration=trial_duration_s,
                xnodes=xnodes, ynodes=ynodes,
                up_factor=up_factor,
                temp_freq=temp_freq_cps,
                temp_kernel_length=temp_kernel_len,
                spatial_freq=spatial_freq_cpd
            )
            for frame in trippy_trial_frames(
                cond, fps=fps,
                screen_deg_x=screen_deg_x, screen_deg_y=screen_deg_y,
                michelson_contrast=michelson_contrast, mean_luminance=mean_luminance
            ):
                writer.append_data(frame)
    finally:
        writer.close()
    print(f"Saved MP4: {Path(outfile).resolve()}")

# =========================
# Run
# =========================
if __name__ == "__main__":
    render_trippy_concatenated(
        outfile="trippy_150s_1920x1200_30fps_120x95.mp4",
        trials=10,                 # 10 × 15s = 2.5 min
        trial_duration_s=15.0,
        fps=30,
        tex_x=1920, tex_y=1200,
        xnodes=8, ynodes=6,
        up_factor=None,           # auto (ceil(max(1920/8, 1200/6)) = 240)
        temp_kernel_len=61,
        temp_freq_cps=4.0,
        spatial_freq_cpd=0.06,    # c/deg; scaling already accounts for screen_deg_x
        screen_deg_x=120.0,       # ← updated FoV
        screen_deg_y=95.0,        # ← updated FoV
        seed0=1,
        michelson_contrast=1.0,
        mean_luminance=0.5,
        codec="libx264", pix_fmt="yuv420p", crf=18, bitrate=None
    )